# Успешная модель ветвления Git

Оригинал этой и других статей находиться [здесь](https://nvie.com/posts/a-successful-git-branching-model/).

{% hint style="info" %}
Записка для размышления (5 марта 2020 г.)

Эта модель была задумана в 2010 году, то есть более 10 лет назад, и вскоре после появления самого **Git.** За эти 10 лет **git-flow** (модель ветвления, изложенная в этой статье) стал чрезвычайно популярным во многих командах разработчиков программного обеспечения до такой степени, что люди начали рассматривать его как своего рода стандарт - но, к сожалению, также как догму или панацею.

За эти 10 лет **Git** сам покорил мир, и самый популярный тип программного обеспечения, разрабатываемого с помощью **Git**, все больше смещается в сторону веб-приложений - по крайней мере, в моем пузыре фильтров. Веб-приложения обычно доставляются непрерывно, без отката, и вам не нужно поддерживать несколько версий программного обеспечения, работающих в «дикой природе».

Это не тот класс программного обеспечения, о котором я имел в виду, когда писал в блоге 10 лет назад. Если ваша команда выполняет непрерывную поставку программного обеспечения, я бы предложил использовать гораздо более простой рабочий процесс (например, поток **GitHub**) вместо того, чтобы пытаться внедрить **git-flow** в свою команду.

Если, однако, вы создаете программное обеспечение с явным управлением версиями, или если вам нужно поддерживать несколько версий вашего программного обеспечения в «дикой природе», то **git-flow** может по-прежнему подходить для вашей команды так же хорошо, как и для людей в ней последние 10 лет. В таком случае, пожалуйста, продолжайте читать.

В заключение, всегда помните, что панацеи не существует. Учитывайте свой собственный контекст. Не ненавидь. Решайте сами.
{% endhint %}

В этом посте я представляю модель разработки, которую я представил для некоторых своих проектов (как рабочих, так и частных) около года назад и которая оказалась очень успешной. Я уже давно собирался написать об этом, но до сих пор не находил времени, чтобы сделать это основательно. Я не буду говорить ни о каких деталях проекта, просто о стратегии ветвления и управлении выпусками.

![](../../.gitbook/assets/git-model.png)

## Почему Git?

Подробное обсуждение плюсов и минусов Git по сравнению с централизованными системами управления исходным кодом см. в [интернете](https://git.wiki.kernel.org/index.php/GitSvnComparsion). Там идет множество огненных войн. Как разработчик, я предпочитаю Git всем остальным инструментам на сегодняшний день. Git действительно изменил представление разработчиков о слиянии и ветвлении. В классическом мире CVS / Subversion, из которого я пришел, слияние / ветвление всегда считалось немного пугающим («остерегайтесь конфликтов слияния, они вас кусают!») И тем, что вы делаете только время от времени.

Но с Git эти действия чрезвычайно дешевы и просты, и на самом деле они считаются одной из основных частей вашего повседневного рабочего процесса. Например, в [книгах](https://svnbook.red-bean.com/) по CVS / Subversion ветвление и слияние сначала обсуждается в последующих главах (для опытных пользователей), тогда как в [каждой](http://book.git-scm.com/) [книге](https://pragprog.com/titles/tsgit/pragmatic-version-control-using-git/) [Git](https://github.com/progit/progit) они уже рассматриваются в главе 3 (основы).

Вследствие своей простоты и повторяемости, ветвления и слияния больше не следует бояться. Инструменты контроля версий должны помогать в ветвлении / слиянии больше, чем что-либо еще.

Довольно об инструментах, давайте перейдем к модели разработки. Модель, которую я собираюсь представить здесь, по сути, является не более чем набором процедур, которым должен следовать каждый член команды, чтобы прийти к управляемому процессу разработки программного обеспечения.

## Децентрализовано, но централизовано

Конфигурация репозитория, которую мы используем и которая хорошо работает с этой моделью ветвления, - это репозиторий с центральным «истинным» репо. Обратите внимание, что это репо считается только центральным (поскольку Git - это DVCS, на техническом уровне нет такой вещи, как центральное репо). Мы будем называть это репо **origin**, поскольку это имя знакомо всем пользователям Git.

![](../../.gitbook/assets/centr-decentr.png)

Каждый разработчик _**pulls**_ и _**pushes**_ к источнику. Но помимо централизованных двухтактных отношений, каждый разработчик может также получать изменения от других партнеров, чтобы сформировать подгруппы. Например, это может быть полезно для совместной работы с двумя или более разработчиками над большой новой функцией, прежде чем преждевременно перемещать незавершенную работу в исходную. На рисунке выше представлены подкоманды Алисы и Боба, Алисы и Дэвида, а также Клера и Дэвида.

Технически это означает не что иное, как то, что Алиса определила удаленный Git с именем _**bob**_, указывающий на репозиторий Боба, и наоборот.

## Основные ветви

По сути, модель разработки во многом вдохновлена существующими моделями. Центральное репо имеет две основные ветки с бесконечным сроком жизни:

* **master**
* **develop**

![](../../.gitbook/assets/main-branches.png)

Основная ветка в **origin** должна быть знакома каждому пользователю Git. Параллельно с основной веткой существует еще одна ветка, которая называется **develop**.

Мы считаем **origin / master** основной веткой, в которой исходный код **HEAD** всегда отражает _**состояние готовности к производству**_.

Мы считаем **origin / develop** основной веткой, в которой исходный код **HEAD** всегда отражает состояние с последними внесенными изменениями разработки для следующего выпуска. Некоторые назвали бы это «интеграционной ветвью». Отсюда и создаются автоматические ночные сборки.

Когда исходный код в ветке **develop** достигает стабильной точки и готов к выпуску, все изменения должны быть каким-то образом объединены обратно в **master**, а затем помечены номером выпуска. О том, как это делается, мы поговорим далее.

Следовательно, каждый раз, когда изменения объединяются обратно в **master**, это по определению новый _**производственный выпуск**_. Мы, как правило, очень строги в этом отношении, поэтому теоретически мы могли бы использовать скрипт перехвата Git для автоматической сборки и развертывания нашего программного обеспечения на наших производственных серверах каждый раз, когда на главном сервере выполнялась фиксация.

## Вспомогательные ветви

Наряду с основными ветвями **master** и **develop** наша модель разработки использует множество поддерживающих ветвей, чтобы способствовать параллельной разработке между членами команды, упростить отслеживание функций, подготовиться к выпуску производственных версий и помочь в быстром исправлении производственных проблем. В отличие от основных веток, эти ветки всегда имеют ограниченный срок службы, так как со временем они будут удалены.

Мы можем использовать следующие типы веток:

* Функциональные ветви
* Ветви выпуска
* Ветви исправлений

Каждая из этих ветвей имеет определенную цель и привязана к строгим правилам относительно того, какие ветви могут быть их исходной ветвью, а какие должны быть их целями слияния. Мы пройдемся по ним через минуту.

Эти отрасли ни в коем случае не являются «особенными» с технической точки зрения. Типы веток классифицируются по тому, как мы их используем. Это, конечно же, старые ветки Git.

### Функциональные ветви

* Может ответвляться от: **develop**
* Должен снова слиться с: **develop**
* Соглашение об именах ветвей: все, кроме **master**, **develop**, **release-\*** или **hotfix-\***

![](../../.gitbook/assets/fb.png)

Ветки функций (или иногда называемые ветвями тем) используются для разработки новых функций для предстоящего или отдаленного будущего выпуска. Когда начинается разработка функции, целевая версия, в которую она будет включена, может быть неизвестна на тот момент. Суть функциональной ветки заключается в том, что она существует, пока функция находится в разработке, но в конечном итоге будет снова объединена с **develop** (чтобы определенно добавить новую функцию в предстоящий выпуск) или отброшена (в случае неутешительного эксперимента).

Ветви функций обычно существуют только в репозиториях разработчиков, а не в **origin**.

#### Создание функциональной ветви

Начиная работу над новой функцией, отойдите от ветки **develop**.

```bash
$ git checkout -b myfeature develop
Switched to a new branch "myfeature"
```

#### Включение готовой функции в develop

Готовые функции могут быть объединены в ветку **develop**, чтобы обязательно добавить их в предстоящий выпуск:

```bash
$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff myfeature
Updating ea1b82a..05e9557
(Summary of changes)
$ git branch -d myfeature
Deleted branch myfeature (was 05e9557).
$ git push origin develop
```

Флаг **--no-ff** заставляет слияние всегда создавать новый объект фиксации, даже если слияние может быть выполнено с быстрой перемоткой вперед. Это позволяет избежать потери информации об историческом существовании ветки функции и группирует вместе все коммиты, которые вместе добавили функцию. Сравнивать:

![](../../.gitbook/assets/merge-without-ff.png)

В последнем случае невозможно увидеть из истории Git, какие из объектов фиксации вместе реализовали функцию - вам придется вручную читать все сообщения журнала. Отмена всей функции (то есть группы коммитов) - настоящая головная боль в последней ситуации, тогда как это легко сделать, если использовать флаг **--no-ff**.

Да, он создаст еще несколько (пустых) объектов фиксации, но выигрыш намного больше, чем стоимость.

### Ветви выпуска

* Может ответвляться от: **develop**
* Должен снова слиться с: **develop** и **master**
* Соглашение об именах филиалов: **release-\***

Ветки выпуска поддерживают подготовку нового производственного выпуска. Они позволяют в последнюю минуту расставлять точки над i и пересечения с t. Кроме того, они позволяют исправлять мелкие ошибки и подготавливать метаданные для выпуска (номер версии, даты сборки и т. д.). Выполняя всю эту работу над веткой выпуска, ветка **develop** очищается для получения функций для следующего большого выпуска.

Ключевой момент для отделения новой ветки выпуска от **develop** - это когда разработка (почти) отражает желаемое состояние нового выпуска. По крайней мере, все функции, предназначенные для будущего выпуска, должны быть объединены в **develop** на данный момент. Все функции, предназначенные для будущих выпусков, могут не быть - они должны ждать, пока ветвь выпуска не будет разветвлена.

Именно в начале ветки выпуска будущему выпуску присваивается номер версии, а не ранее. До этого момента ветка **develop** отражала изменения для «следующего выпуска», но неясно, станет ли этот «следующий выпуск» в конечном итоге 0.3 или 1.0, пока не будет запущена ветвь выпуска. Это решение принимается при запуске ветки выпуска и выполняется в соответствии с правилами проекта по изменению номера версии.

#### Создание релизной ветки

Ветви выпуска создаются из ветки **develop**. Например, предположим, что версия 1.1.5 - это текущий производственный выпуск, и у нас скоро будет большой выпуск. Состояние **develop** готово к «следующему выпуску», и мы решили, что он станет версией 1.2 (а не 1.1.6 или 2.0). Поэтому мы разветвляемся и даем ветке выпуска имя, отражающее номер новой версии:

```bash
$ git checkout -b release-1.2 develop
Switched to a new branch "release-1.2"
$ ./bump-version.sh 1.2
Files modified successfully, version bumped to 1.2.
$ git commit -a -m "Bumped version number to 1.2"
[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)
```

После создания новой ветки и переключения на нее мы увеличиваем номер версии. Здесь **bump-version.sh** - это вымышленный сценарий оболочки, который изменяет некоторые файлы в рабочей копии, чтобы отразить новую версию. (Это, конечно, может быть ручное изменение - дело в том, что _некоторые_ файлы меняются.) Затем номер версии с измененным кодом фиксируется.

Эта новая ветка может существовать там какое-то время, пока релиз не будет окончательно развернут. В течение этого времени исправления ошибок могут применяться в этой ветке (а не в ветке **develop**). Добавлять сюда большие новые функции строго запрещено. Их нужно объединить в **develop**, а значит, ждать следующего большого релиза.

#### Завершение ветки релиза

Когда состояние ветки релиза готово стать настоящим релизом, необходимо выполнить некоторые действия. Во-первых, ветвь релиза объединяется с **master** (помните, поскольку каждая фиксация на **master** является новой версией _**по определению**_). Затем эта фиксация на **master** должна быть помечена для удобства использования в будущем для этой исторической версии. Наконец, изменения, внесенные в ветку выпуска, необходимо снова включить в **develop**, чтобы будущие выпуски также содержали эти исправления ошибок.

Первые два шага в Git:

```bash
$ git checkout master
Switched to branch 'master'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2
```

Релиз готов и помечен для использования в будущем.

{% hint style="info" %}
**Изменение**: вы также можете использовать флаги **-s** или **`-u <key>`** для криптографической подписи вашего тега.
{% endhint %}

Однако, чтобы сохранить изменения, внесенные в ветку релиза, нам нужно объединить их обратно в **develop**. В Git:

```bash
$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff release-1.2
Merge made by recursive.
(Summary of changes)
```

Этот шаг вполне может привести к конфликту слияния (возможно, даже, поскольку мы изменили номер версии). Если да, исправьте это и сделайте коммит.

Теперь мы действительно закончили, и ветвь выпуска может быть удалена, поскольку она нам больше не нужна:

```bash
$ git branch -d release-1.2
Deleted branch release-1.2 (was ff452fe).
```

### Ветви исправлений

* Может ответвляться от: **master**
* Должна снова слиться с: **develop** и **master**
* Соглашение об именах филиалов: **hotfix-\***

![](../../.gitbook/assets/hotfix-branches.png)

Ветви исправлений очень похожи на ветки выпуска, поскольку они также предназначены для подготовки к новому производственному выпуску, хотя и незапланированному. Они возникают из-за необходимости немедленно действовать в случае нежелательного состояния живой производственной версии. Когда критическая ошибка в производственной версии должна быть устранена немедленно, ветвь исправления может быть отделена от соответствующего тега в основной ветке, который отмечает производственную версию.

Суть в том, что работа членов команды (над веткой **develop**) может продолжаться, пока другой человек готовит быстрое производственное исправление.

#### Создание ветки исправлений

Ветви исправлений создаются из **master** ветки. Например, предположим, что версия 1.2 - это текущий производственный выпуск, работающий в реальном времени и вызывающий проблемы из-за серьезной ошибки. Но изменения по **develop** пока нестабильны. Затем мы можем отделиться от ветки исправлений и начать устранение проблемы:

```bash
$ git checkout -b hotfix-1.2.1 master
Switched to a new branch "hotfix-1.2.1"
$ ./bump-version.sh 1.2.1
Files modified successfully, version bumped to 1.2.1.
$ git commit -a -m "Bumped version number to 1.2.1"
[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)
```

Не забудьте увеличить номер версии после разветвления!

Затем исправьте ошибку и зафиксируйте исправление одним или несколькими отдельными коммитами.

```bash
$ git commit -m "Fixed severe production problem"
[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)
```

#### Завершение ветки исправлений

По завершении исправление необходимо снова объединить с **master**, но также необходимо снова включить в **develop**, чтобы гарантировать включение исправления и в следующий выпуск. Это полностью похоже на то, как завершаются ветки выпуска.

Сначала обновите **master** и отметьте выпуск.

```bash
$ git checkout master
Switched to branch 'master'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
$ git tag -a 1.2.1
```

{% hint style="info" %}
**Изменение**: вы также можете использовать флаги **-s** или **`-u <key>`** для криптографической подписи вашего тега.
{% endhint %}

Затем включите исправление в **develop**:

```bash
$ git checkout develop
Switched to branch 'develop'
$ git merge --no-ff hotfix-1.2.1
Merge made by recursive.
(Summary of changes)
```

Единственным исключением из этого правила является то, что, _**когда в настоящее время существует ветвь выпуска, изменения исправления необходимо объединить в эту ветвь выпуска**,_ а не в **develop**. Обратное слияние исправления с ветвью выпуска в конечном итоге приведет к слиянию исправления с **develop**, когда ветка выпуска будет завершена. (Если для работы в **develop** немедленно требуется это исправление, и вы не можете дождаться завершения ветки выпуска, вы также можете безопасно добавить исправление в **develop** уже сейчас.)

Наконец, удалите временную ветку:

```bash
$ git branch -d hotfix-1.2.1
Deleted branch hotfix-1.2.1 (was abbe5d6).
```

## В итоге

Хотя в этой модели ветвления нет ничего шокирующего нового, общая картина, с которой начался этот пост, оказалась чрезвычайно полезной в наших проектах. Он формирует элегантную ментальную модель, которую легко понять, и позволяет членам команды выработать общее понимание процессов ветвления и выпуска.

Здесь представлена высококачественная версия рисунка в формате PDF. Повесьте его на стену для быстрого доступа в любое время.

Обновление: И для всех, кто его просил: вот [gitflow-model.src.key](http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip) основного изображения диаграммы (Apple Keynote).
